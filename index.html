<!DOCTYPE html>
<html lang="de-ch">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Doku 105</title>
    <link href="styles.css" rel="stylesheet" type="text/css">
    <link rel="icon" href="https://www.getsoftwareservice.com/wp-content/uploads/2015/05/SQL-Training.png">
</head>

<body>
    <header>
        <nav class="navdropdown">
            <div class="dropdown">
                <button class="dropbtn0">Start</button>
                <div class="dropdown-content">
                    <a href="#01">Nach oben</a>
                    <a href="#02">SQL Allgemein</a>
                    <a href="#03">Installation & Vorbereitung</a>
                    <a href="#04">Datentypen</a>
                    <a href="#05">Funktionen & Operatoren</a>
                </div>
            </div>
            <div class="dropdown">
                <button class="dropbtn1">SQL Sprachen</button>
                <div class="dropdown-content">
                    <a href="#06">Übersicht Sprachen</a>
                    <a href="#07">DDL</a>
                    <a href="#08">DCL</a>
                    <a href="#09">DML</a>
                    <a href="#10">DQL</a>
                </div>
            </div>
            <div class="dropdown">
                <button class="dropbtn2">Verbindungen</button>
                <div class="dropdown-content">
                    <a href="#11">Verbindungen mit SQL</a>
                    <a href="#12">Relationale Datenbanken</a>
                    <a href="#13">Modellieren & Normalisieren</a>
                    <a href="#14">JOINs</a>
                </div>
            </div>
        </nav>
    </header>
    <main>
        <h1 id="01" class="titel">
            Modul 105 - Datenbanken bearbeiten
        </h1>
        <h1 id="02">
            SQL
        </h1>
        <p>
            SQL heisst ausgeschrieben <b>Structured Query Language</b> und ist nichts Anderes wie eine
            Datenbanksprache, welche die Möglichkeiten zum Einfügen, Verändern, Löschen und Abfragen von Datenbanken
            bietet. <br> Ihre Syntax ist relativ einfach aufgebaut. Jedoch gibt es unterschiedliche "Dialekte" also
            Abweichungen von verwandten SQL Sprachen, wie zum Beispiel MySQL oder SQL-Server. <br> <br> SQL
            funktioniert grundsätzlich so, dass man als allererstes Datenbanken erstellen, bearbeiten und löschen kann.
            <br> Darin sind dann Tabellen. Tabellen können auch untereinander verknüpft werden. <br> In Tabellen hat es
            dann Spalten welche einem Attribut entsprechen.
        </p>
        <h2 id="03">
            Installation & Vorbereitung von SQL
        </h2>
        <p>
            Ich gehe auf die Installation bei einer Linux-Distribution ein, da wir uns im Terminal aufhalten
            werden. <br> Bekanntlich sind Installation mit Linux ziemlich banal, auch hier ist es keine Schwierigkeit
            SQL zu benutzen. Wir benutzen am besten MySQL um allen Linux-Distribution gleiche Voraussetzungen zu
            schaffen. Die Version 4.0.13 ist zwar etwas veraltet, jedoch beinhaltet sie Alles was wir brauchen und
            nicht mehr und nicht weniger. <br> Installieren tut man MySQL mit folgenden Befehlen im Terminal: <br>- sudo
            apt-get install mysql <br>- Passwort eingeben <br>- Y schreiben <br> Und schon ist MySQL installiert. Ab
            jetzt kann man MySQL mit diesem Befehl öffnen: <br> mysql -u root -p <br> Und dann kann man das Passwort
            eingeben, welches man bei der Installation im pinken Dialogfenster definiert hat. Somit ist man nun in
            MySQL.
        </p>
        <h2 id="04">
            Datentypen
        </h2>
        <p>
            Bei SQL gibt es unterschiedliche Datentypen mit jeweils bestimmten Eigenschaften. Man sollte sie unbedingt
            unterscheiden, um später alle Funktionen von SQL nutzen zu können. <br> Mit dem unten abgebildeten
            Flussdiagramm können sie mit Leichtigkeit Den richtigen Datentyp für ihr Attribut herausfinden.<br>
            <img class="B1" src="Datentypen.jpg" alt="Flussdiagramm Datentypen">
        </p>
        <h2 id="05">
            Funktionen & Operatoren
        </h2>
        <p>
            Mit SQL kommen diverse vorgegebene Funktionen, mit welchen bestimmte Operationen durchgeführt werden können.
            In MySQL ist es leider nicht möglich eigene Funktionen zu definieren. Es ist zwar prinzipiell möglich, wenn
            sie in C++ geschrieben sind, in einer Datenbank gespeichert wurden und zusätzlich das dynamische Laden von
            Bibliotheken erlaubt ist. Aber darauf werde ich jetzt nicht weiter eingehen. <br> <br> Bei den meisten
            Funktionen darf zwischen dem Namen und der ersten öffnenden Klammer <b>KEIN</b> Leerzeichen enthalten sein,
            sonst gibt es eine Fehlermeldung! Um dieses Risiko zu vermeiden, sollte man sich direkt angewöhnen nie ein
            Leerzeichen zu setzen. <br> <br> Eine komplette Liste aller MySQL Funktionen zu machen wäre unübersichtlich,
            ich mache daher lieber eine kleinere Liste, die aber nur die essenziellen Funktionen beinhaltet. Hier ist
            sie: <br>
            ABS() - Rechnet den Betrag aus <br>
            AVG() - Ergibt den Durchschnitt von allen ausgewählten Werten <br>
            CEILING() / CEIL() - Rundet die Zahl auf <br>
            COUNT() - Ergibt die Anzahl an von einer Tabelle, welche eine bestimmte Bedingung erfüllen <br>
            FLOOR() - Rundet die Zahl ab <br>
            LOWER() - Ergibt den Wert in Grossbuchstaben <br>
            MAX() - Ergibt das Maximum aus einem bestimmten Bereich <br>
            MIN() - Ergibt das Minimum aus einem bestimmten Bereich <br>
            PI() - Gibt Pi aus <br>
            RAND() - Ergibt eine zufällige Zahl zwischen 0 und 1 ohne 1 <br>
            REVERSE() - Ergibt den ausgewählten Wert rückwärts angezeigt <br>
            ROUND() - Rundet die Zahl mathematisch auf oder ab <br>
            SIGN() - Ergibt eine 1 bei positiven Zahlen, eine -1 bei negativen Zahlen und eine 0 bei 0. <br>
            SQRT() - Ergibt die Quadratwurzel von der Zahl <br>
            UPPER() - Ergibt den Wert in Kleinbuchstaben
        </p>
        <h1 id="06">
            Übersicht Sprachen
        </h1>
        <p>
            Um SQL genauer verstehen zu können, sollten wir die vier Teilsprachen unterscheiden. Unterschieden wird
            zwischen DDL=Data Definition Language, DCL=Data Control Language, DML=Data Manipulation Language und
            DQL=Data Query Language.
        </p>
        <h2 id="07">
            Data Definition Language
        </h2>
        <p>
            Die DDL dient dazu, Datenbanken und Tabellen zu erstellen, bearbeiten, löschen und Informationen über
            Tabellen und deren Erstellung anzeigen zu lassen. Gemacht wird dies mit folgenden Statements: <br>
            CREATE - CREATE TABLE Tabelle <br>
            ALTER - ALTER TABLE Tabelle DROP Attribut <br>
            DROP - DATABASE Datenbank <br>
            DESCRIBE - DESCRIBE Tabelle <br>
            SHOW - SHOW CREATE TABLE Tabelle
        </p>
        <h2 id="08">
            Data Control Language
        </h2>
        <p>
            Wie man dem Namen Data Control Language schon entnehmen kann, geht es bei der DCL um Kontrolle, also um
            Rechte. Hier kann man Rechte zuweisen und entnehmen oder auch Rechte von Benutzern anzeigen lassen. Man kann
            Nutzer vor dem Rechte zuweisen auch manuell erstellen, da dies aber meiner Meinung nach keinen Sinn
            aufweist, gehe ich darauf auch nicht ein. Hier sind die drei brauchbaren Statements:<br>
            GRANT - GRANT RechteXY ON Datenbank.Tabelle TO Benutzer IDENTIFIED BY 'Passwort' WITH GRANT OPTION <br>
            REVOKE - REVOKE Rechte on Datenbank.Tabelle FROM Benutzer <br>
            SHOW GRANTS - SHOW GRANTS FOR Benutzer <br>
        </p>
        <h2 id="09">
            Data Manipulation Language
        </h2>
        <p>
            Am meisten in der Praxis genutzt wird wahrscheinlich die DML. Den damit werden einzelne Datensätze erstellt,
            verändert und gelöscht, dies funktioniert so: <br>
            INSERT INTO - INSERTO INTO Tabelle VALUES (0,'XxxYyyZzz',1) WHERE x=0 <br>
            UPDATE Tabelle SET Plz=8212 WHERE x=0 <br>
            DELETE FROM - DELETE FROM Tabelle WHERE x=0
        </p>
        <h2 id="10">
            Data Query Language
        </h2>
        <p>
            Diese Teilsprache befasst sich ausschliesslich mit dem SELECT Statement dieses ist folgendermassen
            aufgebaut: <br>
            SELECT - SELECT Attribut(e) FROM Tabelle <br>
            Jedoch kommen mit dem SELECT Statement diverse optionale Keywords, wichtig bei ihnen ist, dass sie auch in
            dieser Reihenfolge angeordnet sind: <br>
            WHERE x=2 - Filtert alle Datensätze raus, die diese Bedingung nicht erfüllen <br>
            GROUP BY Attribut - Gruppiert nach einem Attribut <br>
            HAVING x=0 - Filtert zusätzlich nach dem GROUP BY Keywords <br>
            ORDER BY Attribut(e) (DESC)- Ordnet die Ausgabe entweder auf- oder absteigend
        </p>
        <h1 id="11">
            Verbindungen mit SQL
        </h1>
        <p>
            Um das volle Potenzial von SQL auszuschöpfen, sollte man definitiv Verständnis mit dem Verbinden von SQL
            Tabellen aufweisen können. Wie das Ganze genauer funktioniert und wann dessen Verwendung angebracht ist,
            erkläre ich in diesem Kapitel.
        </p>
        <h2 id="12">
            Relationale Datenbanken
        </h2>
        <p>
            Eine relationale Datenbank ist nichts Anderes wie untereinander verbundene Tabellen, die eine gewisse
            "Beziehung" haben. Beziehung in dem Sinne, dass Veränderungen in der einten Tabelle, zu Veränderungen in
            einer anderen Tabelle führen. Hauptsächlich wird diese Methode bei grösseren Datenbanken verwendet um
            einerseits effizienter arbeiten zu können und andererseits eine redundanzfreie Datenbank zu haben, welche
            eine referentielle Integrität aufweist und somit keine Fehleinträge aufweist. <br> <br> Das Ganze wird mit
            Primär- und Fremdschlüssel bewerkstelligt. Die Schlüssel stellen hierbei die Verbindung zwischen den
            einzelnen Tabellen dar. Ob ein Attribut ein Primär- oder Fremdschlüssel ist, kann man ganz einfach mithilfe
            der DML definieren. <br> <br> Da dies ein eher komplexes Thema ist, verlinke ich <a target="_blank"
                href="https://docs.microsoft.com/en-us/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-2017">HIER</a>
            noch eine nützliche Seite, um die Schlüssel besser kennenlernen zu können.
        </p>
        <h2 id="13">
            Modellieren & Normalisieren
        </h2>
        <p>
            Das Modellieren und Normalisieren baut auf die Relationalen Datenbanken auf, ich empfehle euch daher dieses
            Kapitel zuerst zu lesen. <br> <br>
            Mit dem oben erlernten Wissen, kann man jetzt loslegen. Das Modellieren bezeichnet das einfache Erstellen
            eines Datenbankmodells. Das Normalisieren ist hingegen das Umsortieren, in diesen vorher mit dem Modellieren
            definierten Zustand. Dafür braucht man meist die Primär- und Fremdschlüssel um die Tabellen korrekt
            verknüpfen
            zu können.
        </p>
        <h2 id="14">
            JOINs
        </h2>
        <p>
            JOINs sind für Manche das schwierigste Kapitel im Bereich SQL, ich denke das liegt daran, dass nicht nur
            dessen Verwendung komplex ist, sondern eher die Herleitung, wann der Einsatz von JOINs notwendig ist und
            welcher JOIN gebraucht wird. Wenn man aber diese Grundlagen versteht, kann man mit Leichtigkeit alle Fälle
            mit JOINs meistern. Die JOINs spielen sich in der DQL ab, sprich es sind Abfragen, die Nichts an den
            eigentlichen Tabellen verändern. Jedoch kann man sie auch einfügen nach einer SELECT Funktion, aber dies ist
            nur selten der Fall. <br> <br> Grundsätzlich werden die JOINs in vier einzelne JOINs aufgeteilt: Den
            Inner JOIN, den Left/Right Inner JOIN, den Left/Right Outer JOIN und zuletzt den Full Outer JOIN. <br>
            <img class="B1" src="JOINs.jpg" alt="JOINs">
        </p>
        <h3>
            Inner JOIN
        </h3>
        <p>
            In der Mitte sieht man den inneren JOIN. Aus meinen eigenen Erfahrungen ist dies der meistverwendete JOIN.
            Man verwendet in wenn man aus verschiedenen Tabellen eine Abfrage machen will, die gemeinsame Datensätze
            ausspucken soll. <br> <br> <br> Ein <b>Beispiel</b> hierbei wäre: <br> Man hat eine Tabelle mit
            Produkten(Produkte). <br> Und eine Tabelle mit Kunden(Kunden) <br> Jetzt kann man mit dem Inner JOIN
            abfragen, welche Kunden Produkte bestellt haben, beziehungsweise welche Produkte von Kunden bestellt wurden.
            <br> Die Abfrage würde folgendermassen aussehen: <br> <br> SELECT Produkte.Produktname, Kunden.Vorname,
            Kunden.Nachname <br> FROM Produkte JOIN Kunden <br> ON Produkte.ProduktNr = Kunden.ProduktNr;
            <br>
        </p>
        <h3>
            Left/Right Inner JOIN
        </h3>
        <p>
            Auf mittlerer Höhe links und rechts sieht man den Left Inner JOIN und den Right Inner JOIN. Hier kann der
            Name etwas verwirrend sein, da er ja Left/Right <b>Inner</b> JOIN heisst, obwohl es eigentlich in dem
            Kreismodell nur der äussere Teil ist. Auf jeden Fall ist dieser JOIN auch sehr relevant. <br> <br> <br>
            <b>Beispiel:</b> <br> Nehmen wir wieder die Tabellen Produkte und Kunden. hier spielt es jetzt eine Rolle ob
            man den rechten oder linken inneren JOIN verwendet. <br> Den je nach Anordnung der Tabellen zeigt es
            entweder alle Produkte an, die noch nie von einem Kunden bestellt worden sind oder alle Kunden, die noch nie
            ein Produkt bestellt haben <br> Die Syntax für noch nie bestellte Produkte sieht so aus: <br> <br> SELECT
            Produkte.Produktname <br> FROM Produkte LEFT JOIN Kunden <br> ON Produkte.ProduktNr = Kunden.ProduktNr <br>
            WHERE Kunden.KundenNr IS NULL;
        </p>
        <h3>
            Left/Right Outer JOIN
        </h3>
        <p>
            Oben jeweils rechts und links zu sehen sind die linken und rechten äusseren JOINS. Meiner Meinung nach
            gehört dieser sowie der folgende Full Outer JOIN zu den weniger nützlichen JOINs. Bei dem aktuellen
            Right/Left Outer JOIN ist der Nutzen folgendermassen: Angenommen man hat zwei Tabellen A und B, nun will man
            die Tabelle A sehen mit gegebenenfalls zusätzlichen Informationen aus der Tabelle B. <br> <br> <br> Ich
            versuche
            das Ganze noch ein wenig zu vereinfach mittels eines <b> Beispiels. </b> <br> Für dieses Beispiel nehmen wir
            zwei andere Tabellen. Einerseits Mitarbeiter und andererseits Dienstwagen. <br> Jetzt wollen wir alle
            Mitarbeiter sehen, mit (sofern vorhanden) ihren Dienstwägen. <br> <br> SELECT Mitarbeiter.Vorname,
            Mitarbeiter.Nachname, Mitarbeiter.Abteilung, Dienstwagen.DienstwagenNr, Dienstwagen.Kennzeichen <br> FROM
            Mitarbeiter JOIN Dienstwagen <br> ON Mitarbeiter.MitarbeiterID = Dienstwagen.MitarbeiterID;
        </p>
        <h3>
            Full Outer JOIN
        </h3>
        <p>
            Als letztes gibt es noch den Full Outer JOIN, dieser ist unten links auf dem Bild vorzufinden. Wie oben
            schonn erwähnt, kommt er meiner Erfahrung nach relativ selten vor. Dennoch kann er in bestimmten Situationen
            sehr praktisch sein. <br> <br> <br> Zum <b>Beispiel</b>, wenn man als Datenbankadministrator eine Übersicht
            haben
            will, über die Tabellen Angestellte und Aufträge. Man sieht dann direkt, welche Aufträge noch keine
            zugewiese Angestellte haben sowie welche Angestellte noch keine oder erst wenige Aufträge haben. <br> Eine
            solche Syntax würde dann folgendermassen aussehen: <br> <br> SELECT Angestellte.Vorname,
            Angestellte.Nachname, Auftrag.Bezeichnung <br> FROM Angestellte LEFT JOIN Aufträge <br> ON
            Angestellte.AngestelltenID = Aufträge.AngestelltenID UNION <br> SELECT Angestellte.Vorname,
            Angestellte.Nachname, Auftrag.Bezeichnung <br> FROM Angestellte RIGHT JOIN Aufträge <br> ON
            Angestellte.AngestelltenID = Aufträge.AngestelltenID;
        </p>
    </main>
    <footer>
        <p id="footerid">
            Website von Robin Ehrbar
        </p>
    </footer>
</body>

</html>