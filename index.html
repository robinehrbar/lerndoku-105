<!DOCTYPE html>
<html lang="de-ch">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Doku 105</title>
    <link href="styles.css" rel="stylesheet" type="text/css">
    <link rel="icon" href="https://www.getsoftwareservice.com/wp-content/uploads/2015/05/SQL-Training.png">
</head>

<body>
    <header>
        <nav class="navdropdown">
            <div class="dropdown">
                <button class="dropbtn0">Start</button>
                <div class="dropdown-content">
                    <a href="#01">Nach oben</a>
                    <a href="#02">SQL Allgemein</a>
                    <a href="#03">Installation & Vorbereitung</a>
                    <a href="#04">Datentypen</a>
                    <a href="#05">Funktionen & Operatoren</a>
                    <a href="#05.5">Import & Export</a>
                </div>
            </div>
            <div class="dropdown">
                <button class="dropbtn1">SQL Sprachschichten</button>
                <div class="dropdown-content">
                    <a href="#06">Übersicht Sprachen</a>
                    <a href="#07">DDL</a>
                    <a href="#08">DCL</a>
                    <a href="#09">DML</a>
                    <a href="#10">DQL</a>
                </div>
            </div>
            <div class="dropdown">
                <button class="dropbtn2">Verbindungen</button>
                <div class="dropdown-content">
                    <a href="#11">Verbindungen mit SQL</a>
                    <a href="#12">Relationale Datenbanken</a>
                    <a href="#13">Modellieren & Normalisieren</a>
                    <a href="#14">JOINs</a>
                    <a href="#15">Views</a>
                </div>
            </div>
        </nav>
    </header>
    <main>
        <h1 id="01" class="titel">
            Modul 105 - Datenbanken bearbeiten
        </h1>
        <h1 id="02">
            SQL
        </h1>
        <p>
            SQL heisst ausgeschrieben <b>Structured Query Language</b> und ist nichts Anderes wie eine <b> Datenbanksprache</b>,
            welche die Möglichkeiten zum Einfügen, Verändern, Löschen und Abfragen von Datenbanken bietet. <br> Ihre Syntax
            ist relativ einfach aufgebaut. Allerdings gibt es unterschiedliche "Dialekte" also Abweichungen von verwandten
            SQL Sprachen, wie zum Beispiel MySQL oder SQL-Server. <br> <br> SQL funktioniert grundsätzlich so, dass man als
            allererstes Datenbanken erstellen, bearbeiten und löschen kann.
            <br> Darin sind Tabellen. Diese Tabellen können auch untereinander verknüpft werden. <br> In Tabellen sind Spalten,
            welche einem beim Erstellen definiertem Attribut zugehören.
        </p>
        <h2 id="03">
            Installation & Vorbereitung von SQL
        </h2>
        <p>
            Ich gehe auf die Installation bei einer Linux-Distribution ein, da wir uns im Terminal befinden werden. <br>            Bekanntlich
            sind Installation mit Linux ziemlich banal, auch hier ist es keine Schwierigkeit SQL zu benutzen. Wir verwenden
            am besten MySQL um allen Linux-Distribution gleiche Voraussetzungen zu schaffen. Die Version 4.0.13 ist zwar
            etwas veraltet, jedoch beinhaltet sie Alles was wir brauchen und somit nicht mehr und auch nicht weniger. <br>            Installieren
            tut man MySQL mit folgenden Befehlen im Terminal: <code> sudo apt-get update <br> sudo apt-get install
                mysql-server mysql-client <br>Passwort eingeben <br>Y/J schreiben </code> Und schon ist MySQL installiert.
            Ab jetzt kann man MySQL mit diesem Befehl öffnen: <code>mysql -u root -p</code> Und dann kann man das Passwort
            eingeben, welches man bei der Installation im pinken Dialogfenster definiert hat. Somit ist man nun in MySQL.
        </p>
        <h2 id="04">
            Datentypen
        </h2>
        <p>
            Bei SQL gibt es unterschiedliche Datentypen mit jeweils bestimmten Eigenschaften. Man sollte sie unbedingt unterscheiden,
            um später alle Funktionen von SQL nutzen zu können. <br> Mit dem unten abgebildeten Flussdiagramm
            können sie mit Leichtigkeit Den richtigen Datentyp für ihr Attribut herausfinden.<br>
            <img class="B1" src="Datentypen.jpg" alt="Flussdiagramm Datentypen"> <br> Jetzt möchte ich noch die meiner Meinung
            nach wichtigsten Datentypen genauer erläutern. Dazu gehören für mich: <code> CHAR - Fixe Länge von
                Text vorgegeben, vorgegebene Länge = verbrauchte Bytes <br> VARCHAR - Variable Länge von Text, individuelle
                Länge + 2 = verbrauchte Bytes <br> INT - benutzt man für Zahlen, mit welchen man später potenziell rechnen
                wird <br> BOOLEAN - wenn der Wert entweder true oder false sein soll <br> DATETIME - für das Datum und die
                Zeit der letzten Aktualisierung in der Datenbank </code>
        </p>
        <h2 id="05">
            Funktionen & Operatoren
        </h2>
        <p>
            Mit SQL kommen diverse vorgegebene Funktionen, mit welchen bestimmte Operationen durchgeführt werden können. In MySQL ist
            es leider nicht möglich eigene Funktionen zu definieren. Es ist zwar prinzipiell möglich, wenn sie in C++ geschrieben
            sind, in einer Datenbank gespeichert wurden und zusätzlich das dynamische Laden von Bibliotheken erlaubt ist.
            Aber darauf werde ich jetzt nicht weiter eingehen. <br> <br> Bei den meisten Funktionen darf zwischen
            dem Namen und der ersten öffnenden Klammer <b>KEIN</b> Leerzeichen enthalten sein, sonst gibt es eine Fehlermeldung!
            Um dieses Risiko zu vermeiden, sollte man sich direkt angewöhnen nie ein Leerzeichen zu setzen. <br> <br> Eine
            komplette Liste aller MySQL Funktionen zu machen wäre unübersichtlich, ich mache daher lieber eine kleinere Liste,
            die aber nur die essenziellen Funktionen beinhaltet. Hier ist sie: <code> ABS() - Rechnet den Betrag
                aus <br> AVG() - Ergibt den Durchschnitt von allen ausgewählten Werten <br> CEILING() / CEIL() - Rundet die
                Zahl auf <br> COUNT() - Ergibt die Anzahl an von einer Tabelle, welche eine bestimmte Bedingung erfüllen
                <br> FLOOR() - Rundet die Zahl ab <br> LOWER() - Ergibt den Wert in Grossbuchstaben <br> MAX() - Ergibt das
                Maximum aus einem bestimmten Bereich <br> MIN() - Ergibt das Minimum aus einem bestimmten Bereich <br> PI()
                - Gibt Pi aus <br> RAND() - Ergibt eine zufällige Zahl zwischen 0 und 1, ohne 1 <br> REVERSE() - Ergibt den
                ausgewählten Wert rückwärts angezeigt
                <br> ROUND() - Rundet die Zahl mathematisch auf oder ab <br> SIGN() - Ergibt eine 1 bei positiven Zahlen,
                eine -1 bei negativen Zahlen und eine 0 beim Wert 0. <br> SQRT() - Ergibt die Quadratwurzel von der Zahl
                <br> UPPER() - Ergibt den Wert in Kleinbuchstaben </code>
        </p>
        <h2 id="05.5">
            Import & Export
        </h2>
        <p>
            Das Importieren und Exportieren von Datenbanken ist von grosser Relevanz. Ein Vorteil vom Export ist sicherlich, dass man
            dadurch Back-Ups erstellen kann. Sie können Daten in einer externen Datei speichern, indem sie alle gewünschten
            Daten mit SELECT auswählen und am Schluss
            <code> into outfile 'Pfad' </code> schreiben, so werden die Daten in diese Datei abgespeichert. Tabellen kann
            man mit folgendem Befehl importieren:
            <code> LOAD DATA LOCAL INFILE 'Pfad' INTO Tabelle FIELDS TERMINATED BY ';' </code> Das Zeichen in den Apostrophen
            kann je nach Anwendung variieren, es ist nämlich das Zeichen, welches die einzelnen Felder, in der Importdatei,
            trennt. Wenn Sie eine <b> ganze Datenbank importieren </b> wollen, können sie dies nicht in MYSQL machen. Sie müssen ins
            Terminal gehen und mit dem Befehl
            <code> mysql -p -u root >Pfad </code> wird die ganze Datenbank importiert.
        </p>
        <h1 id="06">
            Übersicht Sprachschichten
        </h1>
        <p>
            Um SQL genauer verstehen zu können, sollten wir die vier Sprachschichten unterscheiden. Unterschieden wird zwischen der <b>DDL</b>=Data
            Definition Language, der <b>DCL</b>=Data Control Language, der <b>DML</b>=Data Manipulation Language und der <b>DQL</b>=Data Query
            Language.
        </p>
        <h2 id="07">
            Data Definition Language
        </h2>
        <p>
            Die DDL dient dazu, Datenbanken und Tabellen zu erstellen, bearbeiten, löschen und Informationen über Tabellen und deren
            Erstellung anzeigen zu lassen. Gemacht wird dies mit folgenden Statements:
            <code>
                CREATE - CREATE TABLE Tabelle (Attribut Datentyp, Attribut Datentyp PRIMARY KEY AUTO_INCREMENT, Attribut Datentyp); <br>                ALTER
                - ALTER TABLE Tabelle DROP Attribut; <br> DROP - DROP DATABASE Datenbank; <br> DESCRIBE - DESCRIBE Tabelle;
                <br> SHOW - SHOW CREATE TABLE Tabelle; </code> Bei CREATE habe ich jetzt nach dem zweiten Attribut
            einen Primary Key gesetzt, dieser soll zugleich eine ID sein, dessen Wert automatisch ansteigt, dies wird mit
            auto_increment bewerkstelligt.
        </p>
        <h2 id="08">
            Data Control Language
        </h2>
        <p>
            Wie man dem Namen Data Control Language schon entnehmen kann, geht es bei der DCL um Kontrolle, also um Rechte. Hier kann
            man Rechte zuweisen und entnehmen oder auch Rechte von Benutzern anzeigen lassen. Man kann Nutzer vor dem Rechte
            zuweisen auch manuell erstellen, da dies aber meiner Meinung nach keinen Sinn aufweist, gehe ich darauf auch
            nicht ein. Hier sind die drei brauchbaren Statements:
            <code> GRANT - GRANT RechteXY ON Datenbank.Tabelle TO Benutzer IDENTIFIED BY 'Passwort' WITH GRANT
                OPTION; <br> REVOKE - REVOKE Rechte on Datenbank.Tabelle FROM Benutzer; <br> SHOW GRANTS - SHOW GRANTS FOR
                Benutzer; </code> Wenn man ganz am Ende bei GRANT noch ein "WITH GRANT OPTION" anhenkt, dann hat
            jener Benutzer die Rechte, Rechte zu verwalten auf der vorher definierten Datenbank.
        </p>
        <h2 id="09">
            Data Manipulation Language
        </h2>
        <p>
            Am meisten in der Praxis genutzt wird wahrscheinlich die DML. Denn damit werden einzelne Datensätze erstellt, verändert und
            gelöscht, dies funktioniert so:
            <code> INSERT INTO - INSERTO INTO Tabelle (Attribut1,Attribut2,Attribut3) VALUES (0,'XxxYyyZzz',1)
                WHERE x=0; <br> UPDATE Tabelle SET Plz=8212 WHERE x=0; <br> DELETE FROM - DELETE FROM Tabelle WHERE x=0; </code>
        </p>
        <h2 id="10">
            Data Query Language
        </h2>
        <p>
            Diese Teilsprache befasst sich ausschliesslich mit dem SELECT Statement dieses ist folgendermassen aufgebaut: <br>            SELECT
            - SELECT Attribut(e) FROM Tabelle <br> Jedoch kommen mit dem SELECT Statement diverse optionale Keywords, wichtig
            bei ihnen ist, dass sie auch in dieser Reihenfolge angeordnet sind: <code> WHERE x=2 - Filtert alle
                Datensätze raus, die diese Bedingung nicht erfüllen <br> GROUP BY Attribut - Gruppiert nach einem Attribut
                <br> HAVING x=0 - Filtert zusätzlich nach dem GROUP BY Keywords <br> ORDER BY Attribut(e) (DESC)- Ordnet
                die Ausgabe entweder auf- oder absteigend </code>
        </p>
        <h1 id="11">
            Verbindungen mit SQL
        </h1>
        <p>
            Um das volle Potenzial von SQL auszuschöpfen, sollte man definitiv Verständnis mit dem Verbinden von SQL Tabellen aufweisen
            können. Wie das Ganze genauer funktioniert und wann dessen Verwendung angebracht ist, erkläre ich in diesem Kapitel.
        </p>
        <h2 id="12">
            Relationale Datenbanken
        </h2>
        <p> 
            Eine relationale Datenbank ist nichts Anderes wie untereinander verbundene Tabellen, die eine gewisse "Beziehung" haben.
            Beziehung in dem Sinne, dass Veränderungen in der einten Tabelle, zu Veränderungen in einer anderen Tabelle führen.
            Hauptsächlich wird diese Methode bei grösseren Datenbanken verwendet um einerseits effizienter arbeiten zu können
            und andererseits eine redundanzfreie Datenbank zu haben, welche eine referentielle Integrität aufweist und somit
            auch keine Fehleinträge aufweist. <br> <br> Das Ganze wird mit Primär- und Fremdschlüssel bewerkstelligt.
            Die Schlüssel stellen hierbei die Verbindung zwischen den einzelnen Tabellen dar. Ob ein Attribut ein Primär-
            oder Fremdschlüssel ist, kann man ganz einfach mithilfe der DML definieren. <br> <br> Da dies ein eher komplexes
            Thema ist, verlinke ich <a target="_blank" href="https://docs.microsoft.com/en-us/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-2017">HIER</a>
            noch eine nützliche Seite, um die Schlüssel besser kennenlernen zu können.
        </p>
        <h2 id="13">
            Modellieren & Normalisieren
        </h2>
        <p>
            Das Modellieren und Normalisieren baut auf die Relationalen Datenbanken auf, ich empfehle euch daher dieses Kapitel zuerst
            zu lesen. <br> <br> Mit dem oben erlernten Wissen, kann man jetzt loslegen. Das Modellieren bezeichnet
            das einfache Erstellen eines Datenbankmodells. Das Normalisieren ist hingegen das Umsortieren, in diesen vorher
            mit dem Modellieren definierten Zustand. Dafür braucht man meist die Primär- und Fremdschlüssel um die Tabellen
            korrekt verknüpfen zu können. <br> <br> <a target="_blank" href="http://www.datenbanken-verstehen.de/datenmodellierung/">HIER</a>
            kann man noch mehr über's Modellieren erfahren und <a target="_blank" href="http://www.datenbanken-verstehen.de/datenmodellierung/normalisierung/">HIER</a>
            gibt es weitere Informationen zur Normalisierung.
        </p>
        <h2 id="14">
            JOINs
        </h2>
        <p> 
            JOINs sind für Manche das schwierigste Kapitel im Bereich SQL, ich denke das liegt daran, dass nicht nur dessen Verwendung
            komplex ist, sondern eher die Herleitung, wann der Einsatz von JOINs notwendig ist und welcher JOIN gebraucht
            wird. Wenn man aber diese Grundlagen versteht, kann man mit Leichtigkeit alle Fälle der JOINs meistern. Die JOINs
            spielen sich in der DQL ab, sprich es sind Abfragen, die Nichts an den eigentlichen Tabellen verändern. Jedoch
            kann man sie auch als Inhalt einfügen nach einer SELECT Funktion, aber dies ist nur selten der Fall. <br>            <br>            Grundsätzlich
            werden die JOINs in vier einzelne JOINs aufgeteilt: Den Inner JOIN, den Left/Right Inner JOIN, den Left/Right
            Outer JOIN und zuletzt den Full Outer JOIN. <br>
            <img class="B1" src="JOINs.jpg" alt="JOINs">
        </p>
        <h3>
            Inner JOIN
        </h3>
        <p>
            In der Mitte sieht man den inneren JOIN. Aus meinen eigenen Erfahrungen ist dies der meistverwendete JOIN. Man verwendet
            ihn wenn man aus verschiedenen Tabellen eine Abfrage machen will, die gemeinsame Datensätze ausspucken soll.
            <br> <br> <br> Ein
            <b>Beispiel</b> hiermit wäre: <br> Man hat eine Tabelle mit Produkten(Produkte). <br> Und eine Tabelle mit Kunden(Kunden)
            <br> Jetzt kann man mit dem Inner JOIN abfragen, welche Kunden Produkte bestellt haben, beziehungsweise welche
            Produkte von Kunden bestellt wurden.
            <br> Die Abfrage würde folgendermassen aussehen: <code> SELECT Produkte.Produktname, Kunden.Vorname,
                Kunden.Nachname
                <br> FROM Produkte JOIN Kunden <br> ON Produkte.ProduktNr = Kunden.ProduktNr; </code>
        </p>
        <h3>
            Left/Right Inner JOIN
        </h3>
        <p>
            Auf mittlerer Höhe links und rechts sieht man den Left Inner JOIN und den Right Inner JOIN. Hier kann der Name etwas verwirrend
            sein, da er ja Left/Right <b>Inner</b> JOIN heisst, obwohl es eigentlich in dem Kreismodell nur der
            äussere Teil ist. Auf jeden Fall ist dieser JOIN auch sehr relevant. Man braucht den JOIN, wenn man nur den Teil
            einer Tabelle haben will, der keine Gemeinsamkeiten mit einer anderen Tabelle hat.
            <br> <br> <br> <b>Beispiel:</b> <br> Nehmen wir wieder die Tabellen Produkte und Kunden. Es spielt grundsätzlich
            keine Rolle ob man den rechten oder linken JOIN verwendet, je nach Anordnung der Tabellen muss man die linke
            oder rechte Tabelle benutzen. <br> Den es wird entweder alle Produkte anzeigen, die noch nie von einem Kunden
            bestellt worden sind oder alle Kunden, die noch nie ein Produkt bestellt haben <br> Die Syntax für noch nie bestellte
            Produkte sieht so aus: <code> SELECT Produkte.Produktname <br> FROM Produkte LEFT JOIN Kunden <br>                ON
                Produkte.ProduktNr = Kunden.ProduktNr <br> WHERE Kunden.KundenNr IS NULL; </code>
        </p>
        <h3>
            Left/Right Outer JOIN
        </h3>
        <p>
            Oben jeweils rechts und links zu sehen sind der linke und der rechte äussere JOIN. Meiner Meinung nach gehört dieser sowie
            der folgende Full Outer JOIN zu den weniger nützlichen JOINs. Bei dem aktuellen Right/Left Outer JOIN ist der
            Nutzen folgendermassen: Angenommen man hat zwei Tabellen A und B, nun will man die Tabelle A sehen mit gegebenenfalls
            zusätzlichen Informationen aus der Tabelle B. <br> <br> <br> Ich versuche das Ganze noch ein wenig
            zu vereinfachen mittels eines <b> Beispiels. </b> <br> Für dieses Beispiel nehmen wir zwei andere Tabellen. Einerseits
            Mitarbeiter und andererseits Dienstwagen. <br> Jetzt wollen wir alle Mitarbeiter sehen, mit (sofern vorhanden)
            ihren Dienstwägen. <code> SELECT Mitarbeiter.Vorname, Mitarbeiter.Nachname, Mitarbeiter.Abteilung,
                Dienstwagen.DienstwagenNr, Dienstwagen.Kennzeichen <br> FROM Mitarbeiter JOIN Dienstwagen <br> ON Mitarbeiter.MitarbeiterID
                = Dienstwagen.MitarbeiterID; </code>
        </p>
        <h3>
            Full Outer JOIN
        </h3>
        <p>
            Als letztes gibt es noch den Full Outer JOIN, dieser ist unten links auf dem Bild vorzufinden. Wie oben schon erwähnt, kommt
            er meiner Erfahrung nach relativ selten vor. Dennoch kann er in bestimmten Situationen sehr praktisch sein. <br>            <br>            <br>            Zum
            <b>Beispiel</b>, wenn man als Datenbankadministrator eine Übersicht haben will, über die Tabellen Angestellte
            und Aufträge. Man sieht dann direkt, welche Aufträge noch keine zugewiesene Angestellte haben sowie welche Angestellte
            noch keine oder erst wenige Aufträge haben. <br> Eine solche Syntax würde dann folgendermassen aussehen:
            <code> SELECT Angestellte.Vorname, Angestellte.Nachname, Auftrag.Bezeichnung <br> FROM Angestellte LEFT JOIN Aufträge
                <br> ON Angestellte.AngestelltenID = Aufträge.AngestelltenID UNION <br> SELECT Angestellte.Vorname, Angestellte.Nachname,
                Auftrag.Bezeichnung <br> FROM Angestellte RIGHT JOIN Aufträge <br> ON Angestellte.AngestelltenID = Aufträge.AngestelltenID;
                </code>
        </p>
        <h2 id="15">
            Views
        </h2>
        <p>
            Views sind sozusagen virtuelle Tabellen die aus SELECT-Abfragen bestehen, Views machen möglich, dass diese jederzeit wieder
            abrufbar sind. Ein View beinhaltet Zeilen und Spalten, wie eine echte Tabelle. Die Felder in einem View sind
            Felder aus einer oder mehreren echten Tabellen der Datenbank. Eine solche View-Syntax sieht so aus:
            <code> CREATE VIEW Viewname AS <br> SELECT Attribut1, Atribut2 <br> FROM Tabelle <br> WHERE x=0; </code> Jetzt
            hat man eine virtuelle Tabelle. Diese kann man jetzt jederzeit wieder aufrufen mit: <code> SELECT * FROM Viewname; </code>            Wenn
            man den View nicht mehr braucht kann man mit <code> DROP VIEW Viewname; </code> den View wieder löschen.
        </p>
    </main>
    <footer>
        <p id="footerid">
            Website von Robin Ehrbar
        </p>
    </footer>
</body>

</html>